# RFC‑0001: Affinari Core Spec (Normative)

| Section | Title |
|---|---|
| 1 | Introduction |
| 2 | Terminology & Concepts |
| 3 | JSON Data Model |
| 4 | Scoring / Matching |
| 5 | Explainability Payload |
| 6 | Versioning & Compatibility |
| 7 | Edge Cases & Fallbacks |
| 8 | Security & Integrity |
| 9 | Appendices & Examples |

---

## 1. Introduction
Affinari’s Core Spec defines the normative rules for schema‑agnostic alignment scoring, explainability, and interoperability. Implementations claiming “Affinari‑compliant” must conform to this spec.

## 2. Terminology & Concepts
- **Schema** — describes trait definitions (types, ranges, semantics).
- **Profile / Profile Instance** — the “user side” traits.
- **Item / Candidate** — the “offer side” traits.
- **Context** — additional qualifiers (time, location, domain constraints).
- **Trait types**:
  - *Scalar* (numeric, real)
  - *Categorical/Ordinal* (enum)
  - *Vector / Multi‑value*
  - *Temporal* (Affinari‑Time extension, see RFC‑0004)
- **Affinity Score** — normalized match value in [0,1].
- **Sponsorship Weight** — optional bounded lift that must not override core alignment.
- **Explainability / “Why This Fit”** — structured payload justifying the score.

## 3. JSON Data Model

### 3.1 Schema Definition (`schema.json`)
```json
{
  "schema_version": "1.0.0",
  "traits": {
    "cleanliness": { "type": "scalar", "min": 0, "max": 5 },
    "room_type": { "type": "categorical", "values": ["single", "double", "suite"] },
    "amenities": { "type": "vector", "values": ["wifi", "pool", "spa", "parking"] }
  }
}
```

### 3.2 Instance / Profile / Item (`*.json`)
```json
{
  "schema_version": "1.0.0",
  "instance_id": "hotel-1234",
  "traits": {
    "cleanliness": 4.2,
    "room_type": "double",
    "amenities": ["wifi", "parking"]
  }
}
```

### 3.3 Context (optional)
```json
{
  "location": { "lat": 51.25, "lon": -3.99 },
  "date": "2025-10-08T14:30:00Z"
}
```

## 4. Scoring / Matching

### 4.1 Per‑trait alignment
- **Scalar**: absolute difference normalized by the trait range, then inverted:  
  s = 1 − |p − i| / (max − min)
- **Categorical / Ordinal**: exact match = 1; mismatch = 0 (or use a domain distance if defined).
- **Vector / Multi‑value**: Jaccard similarity (intersection/union) unless the schema defines weights.

Combine via weighted sum. Normalize by the sum of used weights to bound the score in [0,1].

### 4.2 Sponsorship lift
If `sponsor_weight` > 0, compute `final = base * (1 + α * sponsor_weight)`, where α ≤ 0.1 by default, and clamp at 1.0.

## 5. Explainability Payload

```json
{
  "base_score": 0.83,
  "trait_contributions": { "cleanliness": 0.21, "room_type": 0.35, "amenities": 0.27 },
  "sponsorship_lift": 0.05,
  "final_score": 0.88,
  "notes": ["sponsor lift applied: 5%"]
}
```
Constraint: sum(trait_contributions) = base_score.

## 6. Versioning & Compatibility
- Spec uses SemVer; breaking changes = major bump.
- `schema_version` ties bundles to spec versions.
- Implementations must refuse or fallback on unknown higher major versions.

## 7. Edge Cases & Fallbacks
- Missing trait in item or profile → drop from calculation and renormalize weights.
- Out‑of‑bounds values → clamp or error per schema policy.
- Ties → deterministic tie‑break (e.g., lexicographic `instance_id`).
- Empty profiles / all missing → score 0.

## 8. Security & Integrity
- Optional HMAC or hash fields for tamper detection.
- Versioned schemas prevent silent drift.

## 9. Appendices & Examples
- See `/examples` for worked examples with walkthroughs.
